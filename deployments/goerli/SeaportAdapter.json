{
  "address": "0xCC0B66bBd3fC2c8559DFDe643d5E4eB2A9E1baB0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_seaportAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensToApprove",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "ethAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "approveBeforeFulfill",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensToApprove",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "ethAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "revertIfIncomplete",
          "type": "bool"
        }
      ],
      "name": "approveBeforeFulfillBatch",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "ethAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "fulfill",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "ethAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "revertIfIncomplete",
          "type": "bool"
        }
      ],
      "name": "fulfillBatch",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "seaportAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xdce0ebf939f8b8b3b15f324756f2aeb09dc51ce860f336af21ac754f66d92d8d",
  "receipt": {
    "to": null,
    "from": "0x745E3182275791241eb92036a4A767664c456343",
    "contractAddress": "0xCC0B66bBd3fC2c8559DFDe643d5E4eB2A9E1baB0",
    "transactionIndex": 3,
    "gasUsed": "808466",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x950680d171e763b40a71f8c7bc3ada3e1e2f1e33363d35a728f9d754b3846abf",
    "transactionHash": "0xdce0ebf939f8b8b3b15f324756f2aeb09dc51ce860f336af21ac754f66d92d8d",
    "logs": [],
    "blockNumber": 7221969,
    "cumulativeGasUsed": "1126280",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x00000000006c3852cbEf3e08E8dF289169EdE581"
  ],
  "numDeployments": 1,
  "solcInputHash": "f88f57136358a3b31827c2ad30206828",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_seaportAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToApprove\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveBeforeFulfill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToApprove\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"revertIfIncomplete\",\"type\":\"bool\"}],\"name\":\"approveBeforeFulfillBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fulfill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"revertIfIncomplete\",\"type\":\"bool\"}],\"name\":\"fulfillBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seaportAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"approveBeforeFulfill(address[],uint256,bytes)\":{\"details\":\"This function grants approval for NFTs held by address(this)      to Seaport contract before fulfilling a single order by      calling `fulfillAdvancedOrder()`.\",\"params\":{\"data\":\"The Seaport encoded fulfillment data.\",\"ethAmount\":\"The amount of ETH to be sent when filling the order.\",\"tokensToApprove\":\"The tokens to approve before fulfilling the order.\"}},\"approveBeforeFulfillBatch(address[],uint256,bytes,bool)\":{\"details\":\"This function grants approval for NFTs held by address(this)      to Seaport contract before fulfilling multiple orders by      calling `fulfillAvailableAdvancedOrders()`\",\"params\":{\"data\":\"The ABI encoded params.\",\"ethAmount\":\"The amount of ETH to be sent when filling the orders.\",\"revertIfIncomplete\":\"Flag to revert if one or more orders cannot be fulfilled.\",\"tokensToApprove\":\"The tokens to approve before fulfilling the orders.\"}},\"fulfill(uint256,bytes)\":{\"details\":\"This function calls `fulfillAdvancedOrder()` on Seaport      using the given abi encoded params.\",\"params\":{\"data\":\"The ABI encoded params.\",\"ethAmount\":\"The amount of ETH to be sent when fulfilling the order.\"}},\"fulfillBatch(uint256,bytes,bool)\":{\"details\":\"This function calls `fulfillAvailableAdvancedOrders()` on      Seaport using the given abi encoded params.\",\"params\":{\"data\":\"The ABI encoded params.\",\"ethAmount\":\"The amount of ETH to be sent when calling the fulfillment function.\",\"revertIfIncomplete\":\"Flag to revert if one or more orders cannot be fulfilled.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/shoyu/adapters/Markets/SeaportAdapter.sol\":\"SeaportAdapter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":19066},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@rari-capital/solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0xb59c7c25eca386f39da4819a9f70f89b73b7583d5f5127a83ffe5339800b1183\",\"license\":\"AGPL-3.0-only\"},\"contracts/shoyu/adapters/Markets/SeaportAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC721.sol\\\";\\nimport \\\"seaport/contracts/interfaces/ConsiderationInterface.sol\\\";\\n\\ncontract SeaportAdapter {\\n    address public immutable seaportAddress;\\n\\n    bytes4 private constant fulfillAdvancedOrderSelector = 0xe7acab24;\\n    bytes4 private constant fulfillAvailableAdvancedOrdersSelector = 0x87201b41;\\n\\n    constructor(address _seaportAddress) {\\n        seaportAddress = _seaportAddress;\\n    }\\n\\n    /// @dev This function grants approval for NFTs held by address(this)\\n    ///      to Seaport contract before fulfilling a single order by\\n    ///      calling `fulfillAdvancedOrder()`.\\n    /// @param tokensToApprove      The tokens to approve before fulfilling the order.\\n    /// @param ethAmount            The amount of ETH to be sent when filling the order.\\n    /// @param data                 The Seaport encoded fulfillment data.\\n    function approveBeforeFulfill (\\n        address[] calldata tokensToApprove,\\n        uint256 ethAmount,\\n        bytes calldata data\\n    ) external payable {\\n        uint256 length = tokensToApprove.length;\\n        for (uint256 i; i < length; ++i) {\\n            ERC721 token = ERC721(tokensToApprove[i]);\\n            if (!token.isApprovedForAll(address(this), seaportAddress)) {\\n                token.setApprovalForAll(seaportAddress, true);\\n            }\\n        }\\n\\n        fulfill(ethAmount, data);\\n    }\\n\\n    /// @dev This function grants approval for NFTs held by address(this)\\n    ///      to Seaport contract before fulfilling multiple orders by\\n    ///      calling `fulfillAvailableAdvancedOrders()`\\n    /// @param tokensToApprove      The tokens to approve before fulfilling the orders.\\n    /// @param ethAmount            The amount of ETH to be sent when filling the orders.\\n    /// @param data                 The ABI encoded params.\\n    /// @param revertIfIncomplete   Flag to revert if one or more orders cannot be fulfilled.\\n    function approveBeforeFulfillBatch (\\n        address[] calldata tokensToApprove,\\n        uint256 ethAmount,\\n        bytes calldata data,\\n        bool revertIfIncomplete\\n    ) external payable {\\n        uint256 length = tokensToApprove.length;\\n        for (uint256 i; i < length; ++i) {\\n            ERC721 token = ERC721(tokensToApprove[i]);\\n            if (!token.isApprovedForAll(address(this), seaportAddress)) {\\n                token.setApprovalForAll(seaportAddress, true);\\n            }\\n        }\\n\\n        fulfillBatch(ethAmount, data, revertIfIncomplete);\\n    }\\n\\n    /// @dev This function calls `fulfillAdvancedOrder()` on Seaport\\n    ///      using the given abi encoded params.\\n    /// @param ethAmount      The amount of ETH to be sent when fulfilling the order.\\n    /// @param data           The ABI encoded params.\\n    function fulfill (\\n        uint256 ethAmount,\\n        bytes calldata data\\n    ) public payable {\\n        (bool success, bytes memory results) =\\n            seaportAddress.call{\\n                value: ethAmount\\n            }(abi.encodePacked(fulfillAdvancedOrderSelector, data));\\n\\n        require(success && abi.decode(results, (bool)) , \\\"fullfill/SEAPORT_ORDER_UNFILLABLE\\\");\\n    }\\n\\n    /// @dev This function calls `fulfillAvailableAdvancedOrders()` on\\n    ///      Seaport using the given abi encoded params.\\n    /// @param ethAmount            The amount of ETH to be sent when calling the fulfillment function.\\n    /// @param data                 The ABI encoded params.\\n    /// @param revertIfIncomplete   Flag to revert if one or more orders cannot be fulfilled.\\n    function fulfillBatch (\\n        uint256 ethAmount,\\n        bytes calldata data,\\n        bool revertIfIncomplete\\n    ) public payable {\\n        (bool success, bytes memory results) =\\n            seaportAddress.call{value: ethAmount}(\\n                abi.encodePacked(fulfillAvailableAdvancedOrdersSelector, data)\\n            );\\n\\n        require(success, \\\"fullfillBatch/SEAPORT_REVERTED\\\");\\n\\n        if (revertIfIncomplete) {\\n            (bool[] memory availableOrders,) = abi.decode(results, (bool[], Execution[]));\\n            uint256 length = availableOrders.length;\\n            for (uint256 i; i < length; ++i) {\\n                require(\\n                    availableOrders[i],\\n                    \\\"fulfillBatch/SEAPORT_ORDER_UNFILLABLE\\\"\\n                );\\n            }\\n        }\\n    }\\n}\",\"keccak256\":\"0x7ebac28a45460689f4e385c855aca06b6d4cc343266026d15f420887cfaa4341\",\"license\":\"MIT\"},\"seaport/contracts/interfaces/ConsiderationInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// prettier-ignore\\nimport {\\n    BasicOrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1.1\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with as set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported).\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(OrderComponents[] calldata orders)\\n        external\\n        returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(Order[] calldata orders)\\n        external\\n        returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(OrderComponents calldata order)\\n        external\\n        view\\n        returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(bytes32 orderHash)\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(address offerer)\\n        external\\n        view\\n        returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\",\"keccak256\":\"0x7805c824eb046172bb7fd11a9fc12e9a1b3421771af88665f1baee9bb494c4bf\",\"license\":\"MIT\"},\"seaport/contracts/lib/ConsiderationEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// prettier-ignore\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED\\n}\\n\\n// prettier-ignore\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\n// prettier-ignore\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\n// prettier-ignore\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\n// prettier-ignore\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\",\"keccak256\":\"0xe78faea2c9d9322ca557af34e8d576fe21dab9c995f0657d34ba6c4e94fe9c0f\",\"license\":\"MIT\"},\"seaport/contracts/lib/ConsiderationStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// prettier-ignore\\nimport {\\n    OrderType,\\n    BasicOrderType,\\n    ItemType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 counter;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item and has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the counter,\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be included in a staticcall to\\n *      `isValidOrderIncludingExtraData` on the zone for the order if the order\\n *      type is restricted and the offerer or zone are not the caller.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\",\"keccak256\":\"0xdff3fe285196739bcbf37437ea09cb5db6f479070fdbc8cb37de733be673d234\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461008657601f610e5d38819003918201601f19168301916001600160401b0383118484101761008b5780849260209460405283398101031261008657516001600160a01b038116810361008657608052604051610dbb90816100a282396080518181816101d00152818161029c015281816104d0015281816109410152610ca10152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60806040526004361015610013575b600080fd5b6000803560e01c9081630d9577c61461007a5750806336e1cca41461007157806352c6bfeb14610068578063bba47ad41461005f5763e4dd6d091461005757600080fd5b61000e610460565b5061000e610225565b5061000e610184565b5061000e610114565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100d95760243567ffffffffffffffff81116100d5576100c76100d09136906004016100dc565b906004356108f4565b604051f35b5080fd5b80fd5b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020838186019501011161000e57565b8015150361000e57565b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5760243567ffffffffffffffff811161000e576101626101779136906004016100dc565b6044359161016f8361010a565b600435610c80565b005b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff6004803582811161000e5761027190369083016101f4565b909260443590811161000e578361028c8492369084016100dc565b916064359361029a8561010a565b7f00000000000000000000000000000000000000000000000000000000000000009560005b8181106102d457610177878787602435610c80565b6103066102ed6102ed6102e88486896106e9565b610725565b73ffffffffffffffffffffffffffffffffffffffff1690565b604080517fe985e9c50000000000000000000000000000000000000000000000000000000081523086820190815273ffffffffffffffffffffffffffffffffffffffff8c16602082810191909152939493919082908290819086010381885afa918215610453575b600092610426575b50501561038e575b50610389915061065d565b6102bf565b823b1561000e57517fa22cb46500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a16858201908152600160208201526103899360009183919082908490829060400103925af18015610419575b1561037e578061040d61041392610762565b80610179565b8961037e565b610421610811565b6103fb565b6104459250803d1061044c575b61043d81836107bb565b8101906107fc565b8b80610376565b503d610433565b61045b610811565b61036e565b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff6004803582811161000e576104ac90369083016101f4565b91909260443590811161000e57906104c88492369083016100dc565b9290916000947f0000000000000000000000000000000000000000000000000000000000000000955b8181106105055761017786866024356108f4565b6105196102ed6102ed6102e88486896106e9565b604080517fe985e9c50000000000000000000000000000000000000000000000000000000081523086820190815273ffffffffffffffffffffffffffffffffffffffff8b16602082810191909152939493919082908290819086010381885afa918215610650575b600092610633575b5050156105a1575b5061059c915061065d565b6104f1565b823b1561000e57517fa22cb46500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89168582019081526001602082015261059c9360009183919082908490829060400103925af18015610626575b15610591578061040d61062092610762565b88610591565b61062e610811565b61060e565b6106499250803d1061044c5761043d81836107bb565b8a80610589565b610658610811565b610581565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461068a5760010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b91908110156106fa575b60051b0190565b6107026106b9565b6106f3565b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b3561072f81610707565b90565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff811161077657604052565b61077e610732565b604052565b6060810190811067ffffffffffffffff82111761077657604052565b60a0810190811067ffffffffffffffff82111761077657604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761077657604052565b9081602091031261000e575161072f8161010a565b506040513d6000823e3d90fd5b82600493927fe7acab240000000000000000000000000000000000000000000000000000000083528483013701016000815290565b82600493927f87201b410000000000000000000000000000000000000000000000000000000083528483013701016000815290565b3d156108ef573d9067ffffffffffffffff82116108e2575b604051916108d660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601846107bb565b82523d6000602084013e565b6108ea610732565b6108a0565b606090565b6000929161091161093d859460405192839160208301958661081e565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826107bb565b51917f00000000000000000000000000000000000000000000000000000000000000005af161096a610888565b816109fc575b501561097857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f66756c6c66696c6c2f534541504f52545f4f524445525f554e46494c4c41424c60448201527f45000000000000000000000000000000000000000000000000000000000000006064820152fd5b610a109150602080825183010191016107fc565b38610970565b60209067ffffffffffffffff8111610a2f5760051b0190565b610702610732565b5190610a4282610707565b565b81601f8201121561000e57805190610a5b82610a16565b92604090610a6b825195866107bb565b838552602091828601918360e08097028601019481861161000e578401925b858410610a9b575050505050505090565b8382039087821261000e57835190610ab282610783565b60a080931261000e57845191610ac78361079f565b8651600681101561000e578a9484610b1b928b9652858a0151610ae981610707565b86820152888a0151898201526060808b0151908201526080808b015190610b0f82610707565b82015283528801610a37565b8382015260c087015186820152815201930192610a8a565b91909160408184031261000e5780519267ffffffffffffffff9384811161000e5782019381601f8601121561000e578451610b6d81610a16565b90610b7b60405192836107bb565b808252602096878084019260051b8201019185831161000e5788809201905b838210610bba57505050509483015190811161000e5761072f9201610a44565b8280918351610bc88161010a565b815201910190610b9a565b6020918151811015610be8575b60051b010190565b610bf06106b9565b610be0565b15610bfc57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f66756c66696c6c42617463682f534541504f52545f4f524445525f554e46494c60448201527f4c41424c450000000000000000000000000000000000000000000000000000006064820152fd5b60009291610911610c9d8594604051928391602083019586610853565b51917f00000000000000000000000000000000000000000000000000000000000000005af190610ccb610888565b9115610d2757610cd85750565b80602080610ceb93518301019101610b33565b5080519060005b828110610cfe57505050565b80610d1d610d18610d12610d229486610bd3565b51151590565b610bf5565b61065d565b610cf2565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f66756c6c66696c6c42617463682f534541504f52545f524556455254454400006044820152fdfea2646970667358221220b507a1971b5adc3a379768917b1362b7c7eb5e5469732ebbd2c6840f24dc1eec64736f6c634300080e0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b6000803560e01c9081630d9577c61461007a5750806336e1cca41461007157806352c6bfeb14610068578063bba47ad41461005f5763e4dd6d091461005757600080fd5b61000e610460565b5061000e610225565b5061000e610184565b5061000e610114565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100d95760243567ffffffffffffffff81116100d5576100c76100d09136906004016100dc565b906004356108f4565b604051f35b5080fd5b80fd5b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020838186019501011161000e57565b8015150361000e57565b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5760243567ffffffffffffffff811161000e576101626101779136906004016100dc565b6044359161016f8361010a565b600435610c80565b005b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff6004803582811161000e5761027190369083016101f4565b909260443590811161000e578361028c8492369084016100dc565b916064359361029a8561010a565b7f00000000000000000000000000000000000000000000000000000000000000009560005b8181106102d457610177878787602435610c80565b6103066102ed6102ed6102e88486896106e9565b610725565b73ffffffffffffffffffffffffffffffffffffffff1690565b604080517fe985e9c50000000000000000000000000000000000000000000000000000000081523086820190815273ffffffffffffffffffffffffffffffffffffffff8c16602082810191909152939493919082908290819086010381885afa918215610453575b600092610426575b50501561038e575b50610389915061065d565b6102bf565b823b1561000e57517fa22cb46500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a16858201908152600160208201526103899360009183919082908490829060400103925af18015610419575b1561037e578061040d61041392610762565b80610179565b8961037e565b610421610811565b6103fb565b6104459250803d1061044c575b61043d81836107bb565b8101906107fc565b8b80610376565b503d610433565b61045b610811565b61036e565b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff6004803582811161000e576104ac90369083016101f4565b91909260443590811161000e57906104c88492369083016100dc565b9290916000947f0000000000000000000000000000000000000000000000000000000000000000955b8181106105055761017786866024356108f4565b6105196102ed6102ed6102e88486896106e9565b604080517fe985e9c50000000000000000000000000000000000000000000000000000000081523086820190815273ffffffffffffffffffffffffffffffffffffffff8b16602082810191909152939493919082908290819086010381885afa918215610650575b600092610633575b5050156105a1575b5061059c915061065d565b6104f1565b823b1561000e57517fa22cb46500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89168582019081526001602082015261059c9360009183919082908490829060400103925af18015610626575b15610591578061040d61062092610762565b88610591565b61062e610811565b61060e565b6106499250803d1061044c5761043d81836107bb565b8a80610589565b610658610811565b610581565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461068a5760010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b91908110156106fa575b60051b0190565b6107026106b9565b6106f3565b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b3561072f81610707565b90565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff811161077657604052565b61077e610732565b604052565b6060810190811067ffffffffffffffff82111761077657604052565b60a0810190811067ffffffffffffffff82111761077657604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761077657604052565b9081602091031261000e575161072f8161010a565b506040513d6000823e3d90fd5b82600493927fe7acab240000000000000000000000000000000000000000000000000000000083528483013701016000815290565b82600493927f87201b410000000000000000000000000000000000000000000000000000000083528483013701016000815290565b3d156108ef573d9067ffffffffffffffff82116108e2575b604051916108d660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601846107bb565b82523d6000602084013e565b6108ea610732565b6108a0565b606090565b6000929161091161093d859460405192839160208301958661081e565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826107bb565b51917f00000000000000000000000000000000000000000000000000000000000000005af161096a610888565b816109fc575b501561097857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f66756c6c66696c6c2f534541504f52545f4f524445525f554e46494c4c41424c60448201527f45000000000000000000000000000000000000000000000000000000000000006064820152fd5b610a109150602080825183010191016107fc565b38610970565b60209067ffffffffffffffff8111610a2f5760051b0190565b610702610732565b5190610a4282610707565b565b81601f8201121561000e57805190610a5b82610a16565b92604090610a6b825195866107bb565b838552602091828601918360e08097028601019481861161000e578401925b858410610a9b575050505050505090565b8382039087821261000e57835190610ab282610783565b60a080931261000e57845191610ac78361079f565b8651600681101561000e578a9484610b1b928b9652858a0151610ae981610707565b86820152888a0151898201526060808b0151908201526080808b015190610b0f82610707565b82015283528801610a37565b8382015260c087015186820152815201930192610a8a565b91909160408184031261000e5780519267ffffffffffffffff9384811161000e5782019381601f8601121561000e578451610b6d81610a16565b90610b7b60405192836107bb565b808252602096878084019260051b8201019185831161000e5788809201905b838210610bba57505050509483015190811161000e5761072f9201610a44565b8280918351610bc88161010a565b815201910190610b9a565b6020918151811015610be8575b60051b010190565b610bf06106b9565b610be0565b15610bfc57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f66756c66696c6c42617463682f534541504f52545f4f524445525f554e46494c60448201527f4c41424c450000000000000000000000000000000000000000000000000000006064820152fd5b60009291610911610c9d8594604051928391602083019586610853565b51917f00000000000000000000000000000000000000000000000000000000000000005af190610ccb610888565b9115610d2757610cd85750565b80602080610ceb93518301019101610b33565b5080519060005b828110610cfe57505050565b80610d1d610d18610d12610d229486610bd3565b51151590565b610bf5565b61065d565b610cf2565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f66756c6c66696c6c42617463682f534541504f52545f524556455254454400006044820152fdfea2646970667358221220b507a1971b5adc3a379768917b1362b7c7eb5e5469732ebbd2c6840f24dc1eec64736f6c634300080e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "approveBeforeFulfill(address[],uint256,bytes)": {
        "details": "This function grants approval for NFTs held by address(this)      to Seaport contract before fulfilling a single order by      calling `fulfillAdvancedOrder()`.",
        "params": {
          "data": "The Seaport encoded fulfillment data.",
          "ethAmount": "The amount of ETH to be sent when filling the order.",
          "tokensToApprove": "The tokens to approve before fulfilling the order."
        }
      },
      "approveBeforeFulfillBatch(address[],uint256,bytes,bool)": {
        "details": "This function grants approval for NFTs held by address(this)      to Seaport contract before fulfilling multiple orders by      calling `fulfillAvailableAdvancedOrders()`",
        "params": {
          "data": "The ABI encoded params.",
          "ethAmount": "The amount of ETH to be sent when filling the orders.",
          "revertIfIncomplete": "Flag to revert if one or more orders cannot be fulfilled.",
          "tokensToApprove": "The tokens to approve before fulfilling the orders."
        }
      },
      "fulfill(uint256,bytes)": {
        "details": "This function calls `fulfillAdvancedOrder()` on Seaport      using the given abi encoded params.",
        "params": {
          "data": "The ABI encoded params.",
          "ethAmount": "The amount of ETH to be sent when fulfilling the order."
        }
      },
      "fulfillBatch(uint256,bytes,bool)": {
        "details": "This function calls `fulfillAvailableAdvancedOrders()` on      Seaport using the given abi encoded params.",
        "params": {
          "data": "The ABI encoded params.",
          "ethAmount": "The amount of ETH to be sent when calling the fulfillment function.",
          "revertIfIncomplete": "Flag to revert if one or more orders cannot be fulfilled."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}