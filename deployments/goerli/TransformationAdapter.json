{
  "address": "0xf780B54D0f09FB6938A2C9eDdAa13868b982c3Ae",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_weth",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_pairCodeHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_conduitController",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_bentobox",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "BadReturnValueFromERC20OnTransfer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "identifiers",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "ERC1155BatchTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Invalid1155BatchTransferEncoding",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidERC721TransferAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MissingItemAmount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NoContract",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "identifier",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TokenTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnusedItemParameters",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "bentoBox",
      "outputs": [
        {
          "internalType": "contract IBentoBoxMinimal",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "approve",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "share",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "depositToBentoBox",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "unwrapNative",
          "type": "bool"
        }
      ],
      "name": "swapExactIn",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountInMax",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "enum TokenSource",
          "name": "tokenSource",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "transferData",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "unwrapNative",
          "type": "bool"
        }
      ],
      "name": "swapExactOut",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "enum TokenSource",
          "name": "source",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferERC1155From",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "enum TokenSource",
          "name": "source",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferERC20From",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "enum TokenSource",
          "name": "source",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferERC721From",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "unwrapNativeToken",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "wrapNativeToken",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0xfa6fac7a36218c0d8ec4087725e484e5689fb0317db46e02fbe7045c5d0d1eb1",
  "receipt": {
    "to": null,
    "from": "0x745E3182275791241eb92036a4A767664c456343",
    "contractAddress": "0xf780B54D0f09FB6938A2C9eDdAa13868b982c3Ae",
    "transactionIndex": 6,
    "gasUsed": "2437143",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2568a24f387af73a4d266e37e37ee7c2ee3222bf252621b5ed60f5e75783713d",
    "transactionHash": "0xfa6fac7a36218c0d8ec4087725e484e5689fb0317db46e02fbe7045c5d0d1eb1",
    "logs": [],
    "blockNumber": 7169752,
    "cumulativeGasUsed": "2885349",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6",
    "0xc35DADB65012eC5796536bD9864eD8773aBc74C4",
    "0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303",
    "0x00000000006ce100a8b5ed8edf18ceef9e500697",
    "0xF5BCE5077908a1b7370B9ae04AdC565EBd643966"
  ],
  "numDeployments": 1,
  "solcInputHash": "341995732b39b6fbda29df0a41772b4d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_pairCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_conduitController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bentobox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxMinimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"approve\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositToBentoBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"unwrapNative\",\"type\":\"bool\"}],\"name\":\"swapExactIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"enum TokenSource\",\"name\":\"tokenSource\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"transferData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"unwrapNative\",\"type\":\"bool\"}],\"name\":\"swapExactOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenSource\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC1155From\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenSource\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC20From\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenSource\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC721From\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"unwrapNativeToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrapNativeToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\":[{\"details\":\"Revert with an error when an ERC20 token transfer returns a falsey      value.\",\"params\":{\"amount\":\"The amount for the attempted ERC20 transfer.\",\"from\":\"The source of the attempted ERC20 transfer.\",\"to\":\"The recipient of the attempted ERC20 transfer.\",\"token\":\"The token for which the ERC20 transfer was attempted.\"}}],\"ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])\":[{\"details\":\"Revert with an error when a batch ERC1155 token transfer reverts.\",\"params\":{\"amounts\":\"The amounts for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifiers\":\"The identifiers for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"Invalid1155BatchTransferEncoding()\":[{\"details\":\"Revert with an error when attempting to execute an 1155 batch      transfer using calldata not produced by default ABI encoding or with      different lengths for ids and amounts arrays.\"}],\"InvalidERC721TransferAmount()\":[{\"details\":\"Revert with an error when an ERC721 transfer with amount other than      one is attempted.\"}],\"MissingItemAmount()\":[{\"details\":\"Revert with an error when attempting to fulfill an order where an      item has an amount of zero.\"}],\"NoContract(address)\":[{\"details\":\"Revert with an error when an account being called as an assumed      contract does not have code and returns no data.\",\"params\":{\"account\":\"The account that should contain code.\"}}],\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\":[{\"details\":\"Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.\",\"params\":{\"amount\":\"The amount for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifier\":\"The identifier for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"UnusedItemParameters()\":[{\"details\":\"Revert with an error when attempting to fulfill an order where an      item has unused parameters. This includes both the token and the      identifier parameters for native transfers as well as the identifier      parameter for ERC20 transfers. Note that the conduit does not      perform this check, leaving it up to the calling channel to enforce      when desired.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/shoyu/adapters/Transform/TransformationAdapter.sol\":\"TransformationAdapter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":19066},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\",\"keccak256\":\"0x08f9a63b34855eec941be8d36a04424f1a1725a2c030373fcef3afeb480ca385\",\"license\":\"GPL-3.0\"},\"@sushiswap/core/contracts/uniswapv2/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\",\"keccak256\":\"0x680172744962444cd2f8470d50991336b431fe4e29dd835018ac2f36e53344be\",\"license\":\"GPL-3.0\"},\"contracts/shoyu/adapters/Transfer/BentoAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.11;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"../../../sushiswap/IBentoBoxMinimal.sol\\\";\\n\\n/// @title BentoAdapter\\n/// @notice Adapter which provides all functions of BentoBox require by this contract.\\n/// @dev These are generic functions, make sure, only msg.sender, address(this) and address(bentoBox)\\n/// are passed in the from param, or else the attacker can sifu user's funds in bentobox.\\nabstract contract BentoAdapter {\\n    IBentoBoxMinimal public immutable bentoBox;\\n\\n    constructor(address _bentoBox) {\\n        bentoBox = IBentoBoxMinimal(_bentoBox);\\n    }\\n\\n    // deposits funds from address(this) into bentobox\\n    function depositToBentoBox(\\n        bool approve,\\n        address token,\\n        address to,\\n        uint256 amount,\\n        uint256 share,\\n        uint256 value\\n    ) public {\\n        if (approve) {\\n            ERC20(token).approve(address(bentoBox), type(uint256).max);\\n        }\\n\\n        bentoBox.deposit{value: value}(token, address(this), to, amount, share);\\n    }\\n\\n    /// @notice Deposits the token from users wallet into the BentoBox.\\n    /// @dev Make sure, only msg.sender, address(this) and address(bentoBox)\\n    /// are passed in the from param, or else the attacker can sifu user's funds in bentobox.\\n    /// Pass either amount or share.\\n    /// @param token token to deposit. Use token as address(0) when depositing native token\\n    /// @param from sender\\n    /// @param to receiver\\n    /// @param amount amount to be deposited\\n    /// @param share share to be deposited\\n    /// @param value native token value to be deposited. Only use when token address is address(0)\\n    function _depositToBentoBox(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share,\\n        uint256 value\\n    ) internal {\\n        bentoBox.deposit{value: value}(token, from, to, amount, share);\\n    }\\n\\n    /// @notice Transfers the token from bentobox user to another or withdraw it to another address.\\n    /// @dev Make sure, only msg.sender, address(this) and address(bentoBox)\\n    /// are passed in the from param, or else the attacker can sifu user's funds in bentobox.\\n    /// Pass either amount or share.\\n    /// @param token token to transfer. For native tokens, use wnative token address\\n    /// @param from sender\\n    /// @param to receiver\\n    /// @param amount amount to transfer\\n    /// @param share share to transfer\\n    /// @param unwrapBento use true for withdraw and false for transfer\\n    function _transferFromBentoBox(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share,\\n        bool unwrapBento\\n    ) internal {\\n        if (unwrapBento) {\\n            bentoBox.withdraw(token, from, to, amount, share);\\n        } else {\\n            if (amount > 0) {\\n                share = bentoBox.toShare(token, amount, false);\\n            }\\n            bentoBox.transfer(token, from, to, share);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x72c76039af20bbb811f8a78ce20203fabcf497c272bcd9d352f6c92292fecd0f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/shoyu/adapters/Transfer/ConduitAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport { ConduitControllerInterface } from \\\"seaport/contracts/interfaces/ConduitControllerInterface.sol\\\";\\nimport { ConduitInterface } from \\\"seaport/contracts/interfaces/ConduitInterface.sol\\\";\\nimport { ConduitTransfer } from \\\"seaport/contracts/conduit/lib/ConduitStructs.sol\\\";\\nimport { ConduitItemType } from \\\"seaport/contracts/conduit/lib/ConduitEnums.sol\\\";\\n\\ncontract ConduitAdapter {\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface private immutable _CONDUIT_CONTROLLER;\\n    // Cache the conduit creation hash used by the conduit controller.\\n    bytes32 private immutable _CONDUIT_CREATION_CODE_HASH;\\n\\n    constructor(address _conduitController) {\\n        // Get the conduit creation code hash from the supplied conduit\\n        // controller and set it as an immutable.\\n        ConduitControllerInterface conduitController = ConduitControllerInterface(\\n            _conduitController\\n        );\\n        (_CONDUIT_CREATION_CODE_HASH, ) = conduitController.getConduitCodeHashes();\\n\\n        // Set the supplied conduit controller as an immutable.\\n        _CONDUIT_CONTROLLER = conduitController;\\n    }\\n\\n    function _performERC20TransferWithConduit(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](1);\\n        conduitTransfers[0] = ConduitTransfer(\\n            ConduitItemType.ERC20,\\n            token,\\n            from,\\n            to,\\n            0,\\n            amount\\n        );\\n\\n        // Call the conduit and execute transfer.\\n        ConduitInterface(conduit).execute(conduitTransfers);\\n    }\\n\\n    function _performERC721TransferWithConduit(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](1);\\n        conduitTransfers[0] = ConduitTransfer(\\n            ConduitItemType.ERC721,\\n            token,\\n            from,\\n            to,\\n            tokenId,\\n            1\\n        );\\n\\n        // Call the conduit and execute transfer.\\n        ConduitInterface(conduit).execute(conduitTransfers);\\n    }\\n\\n    function _performERC1155TransferWithConduit(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](1);\\n        conduitTransfers[0] = ConduitTransfer(\\n            ConduitItemType.ERC1155,\\n            token,\\n            from,\\n            to,\\n            tokenId,\\n            amount\\n        );\\n\\n        // Call the conduit and execute transfer.\\n        ConduitInterface(conduit).execute(conduitTransfers);\\n    }\\n}\",\"keccak256\":\"0x3d96c027c33089341828fd2b8532883e2f195835b8eda55ffde6fd61a2d212c9\",\"license\":\"MIT\"},\"contracts/shoyu/adapters/Transfer/TransferAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport \\\"seaport/contracts/lib/TokenTransferrer.sol\\\";\\nimport \\\"./ConduitAdapter.sol\\\";\\nimport \\\"./BentoAdapter.sol\\\";\\nimport { TokenSource } from \\\"../../lib/ShoyuEnums.sol\\\";\\n\\n// TODO: Consider notice in TokenTransferrer.sol, maybe it shouldn't be used here\\ncontract TransferAdapter is TokenTransferrer, ConduitAdapter, BentoAdapter {\\n    constructor(\\n        address _conduitController,\\n        address _bentoBox\\n    )\\n        ConduitAdapter(_conduitController)\\n        BentoAdapter(_bentoBox)\\n    {}\\n\\n    function transferERC20From(\\n        address token,\\n        address to,\\n        uint256 amount,\\n        TokenSource source,\\n        bytes memory data\\n    ) public {\\n        if (source == TokenSource.WALLET) {\\n            _performERC20Transfer(\\n                token,\\n                msg.sender,\\n                to,\\n                amount\\n            );\\n        } else if (source == TokenSource.CONDUIT) {\\n            bytes32 conduitKey = abi.decode(data, (bytes32));\\n\\n            _performERC20TransferWithConduit(\\n                token,\\n                msg.sender,\\n                to,\\n                amount,\\n                conduitKey\\n            );\\n        } else if (source == TokenSource.BENTO) {\\n            bool unwrapBento = abi.decode(data, (bool));\\n\\n            _transferFromBentoBox(\\n                token,\\n                msg.sender,\\n                to,\\n                amount,\\n                0,\\n                unwrapBento\\n            );\\n        } else {\\n            revert(\\\"transferERC20From/INVALID_TOKEN_SOURCE\\\");\\n        }\\n    }\\n\\n    function transferERC721From(\\n        address token,\\n        address to,\\n        uint256 tokenId,\\n        TokenSource source,\\n        bytes memory data\\n    ) public {\\n        if (source == TokenSource.WALLET) {\\n            _performERC721Transfer(\\n                token,\\n                msg.sender,\\n                to,\\n                tokenId\\n            );\\n        } else if (source == TokenSource.CONDUIT) {\\n            bytes32 conduitKey = abi.decode(data, (bytes32));\\n\\n            _performERC721TransferWithConduit(\\n                token,\\n                msg.sender,\\n                to,\\n                tokenId,\\n                conduitKey\\n            );\\n        } else {\\n            revert(\\\"transferERC721From/INVALID_TOKEN_SOURCE\\\");\\n        }\\n    }\\n\\n    function transferERC1155From(\\n        address token,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount,\\n        TokenSource source,\\n        bytes memory data\\n    ) public {\\n        if (source == TokenSource.WALLET) {\\n            _performERC1155Transfer(\\n                token,\\n                msg.sender,\\n                to,\\n                tokenId,\\n                amount\\n            );\\n        } else if (source == TokenSource.CONDUIT) {\\n           bytes32 conduitKey = abi.decode(data, (bytes32));\\n\\n           _performERC1155TransferWithConduit(\\n                token,\\n                msg.sender,\\n                to,\\n                tokenId,\\n                amount,\\n                conduitKey\\n            );\\n        } else {\\n            revert(\\\"transferERC1155From/INVALID_TOKEN_SOURCE\\\");\\n        }\\n    }\\n\\n    /// @dev Transfers some amount of ETH to the given recipient and\\n    ///      reverts if the transfer fails.\\n    /// @param to The recipient of the ETH.\\n    /// @param amount The amount of ETH to transfer.\\n    function _transferEth(address payable to, uint256 amount)\\n        internal\\n    {\\n        assembly {\\n            let success := call(gas(), to, amount, 0, 0, 0, 0)\\n            if eq(success, 0) { revert(0, 0) }\\n        }\\n    }\\n}\",\"keccak256\":\"0x4e1bd7590f59eb60868d7e69195ace335aa5e2c6f8308cbe5b3613fb950e7729\",\"license\":\"MIT\"},\"contracts/shoyu/adapters/Transform/LegacySwapAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\nimport \\\"../Transfer/ConduitAdapter.sol\\\";\\nimport \\\"../Transfer/TransferAdapter.sol\\\";\\nimport { SwapExactOutDetails } from \\\"../../lib/ShoyuStructs.sol\\\";\\nimport { pairFor, sortTokens, getAmountsIn, getAmountsOut } from \\\"../../lib/LibSushi.sol\\\";\\nimport { TokenSource } from \\\"../../lib/ShoyuEnums.sol\\\";\\n\\ncontract LegacySwapAdapter is TransferAdapter {\\n    /// @dev The UniswapV2Factory address.\\n    address private immutable factory;\\n    /// @dev The UniswapV2 pair init code.\\n    bytes32 private immutable pairCodeHash;\\n\\n    constructor(\\n        address _factory,\\n        bytes32 _pairCodeHash,\\n        address _conduitController,\\n        address _bentobox\\n    ) TransferAdapter (_conduitController, _bentobox) {\\n        factory = _factory;\\n        pairCodeHash = _pairCodeHash;\\n    }\\n\\n    // transfers funds from msg.sender and performs swap\\n    function _legacySwapExactOut(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        TokenSource tokenSource,\\n        bytes memory transferData\\n    ) internal returns (uint256 amountIn) {\\n        uint256[] memory amounts = getAmountsIn(\\n            factory,\\n            amountOut,\\n            path,\\n            pairCodeHash\\n        );\\n        amountIn = amounts[0];\\n\\n        require(amountIn <= amountInMax, '_legacySwapExactOut/EXCESSIVE_AMOUNT_IN');\\n\\n        transferERC20From(\\n            path[0],\\n            pairFor(\\n                factory,\\n                path[0],\\n                path[1],\\n                pairCodeHash\\n            ),\\n            amountIn,\\n            tokenSource,\\n            transferData\\n        );\\n\\n        _swap(amounts, path, to);\\n    }\\n\\n    // requires path[0] to have already been sent to address(this)\\n    function _legacySwapExactIn(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to\\n    ) internal returns (uint256 amountOut) {\\n        uint256[] memory amounts = getAmountsOut(\\n            factory,\\n            amountIn,\\n            path,\\n            pairCodeHash\\n        );\\n        amountOut = amounts[amounts.length - 1];\\n\\n        require(amountOut >= amountOutMin, \\\"_legacySwapExactIn/EXCESSIVE_AMOUNT_OUT\\\");\\n\\n        ERC20(path[0]).transfer(\\n            pairFor(\\n                factory,\\n                path[0],\\n                path[1],\\n                pairCodeHash\\n            ),\\n            amountIn\\n        );\\n\\n        _swap(amounts, path, to);\\n    }\\n\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        address _to\\n    ) internal virtual {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n\\n            (address token0, ) = sortTokens(input, output);\\n\\n            uint256 amountOut = amounts[i + 1];\\n\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amountOut)\\n                : (amountOut, uint256(0));\\n            address to = i < path.length - 2 ? pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\\n\\n            IUniswapV2Pair(pairFor(factory, input, output, pairCodeHash)).swap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    \\n}\",\"keccak256\":\"0x5b0a3e3b65950c4d75d649180f68871e57b67524892a61168cbc41fa5ca3037d\",\"license\":\"MIT\"},\"contracts/shoyu/adapters/Transform/TransformationAdapter.sol\":{\"content\":\"pragma solidity >=0.8.11;\\n\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IWETH.sol\\\";\\nimport \\\"./LegacySwapAdapter.sol\\\";\\n\\ncontract TransformationAdapter is LegacySwapAdapter {\\n    address private immutable WETH;\\n\\n    constructor(\\n        address _weth,\\n        address _factory,\\n        bytes32 _pairCodeHash,\\n        address _conduitController,\\n        address _bentobox\\n    ) LegacySwapAdapter(_factory, _pairCodeHash, _conduitController, _bentobox) {\\n        WETH = _weth;\\n    }\\n\\n    // transfers funds from msg.sender & performs swaps\\n    function swapExactOut(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address payable to,\\n        TokenSource tokenSource,\\n        bytes memory transferData,\\n        bool unwrapNative\\n    ) public payable {\\n        _legacySwapExactOut(\\n            amountOut,\\n            amountInMax,\\n            path,\\n            unwrapNative ? address(this) : to,\\n            tokenSource,\\n            transferData\\n        );\\n\\n        if (unwrapNative) {\\n            IWETH(WETH).withdraw(amountOut);\\n            if (to != address(this)) {\\n                _transferEth(to, amountOut);\\n            }\\n        }\\n    }\\n\\n    // requires path[0] to have been sent to address(this)\\n    function swapExactIn(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address payable to,\\n        bool unwrapNative\\n    ) public payable {\\n        uint256 amountOut = _legacySwapExactIn(\\n            amountIn,\\n            amountOutMin,\\n            path,\\n            unwrapNative ? address(this) : to\\n        );\\n\\n        if (unwrapNative) {\\n            IWETH(WETH).withdraw(amountOut);\\n            if (to != address(this)) {\\n                _transferEth(to, amountOut);\\n            }\\n        }\\n\\n    }\\n\\n    // requires WETH to have been sent to address(this)\\n    function unwrapNativeToken(\\n        uint256 amount,\\n        address payable to\\n    ) public payable {\\n        IWETH(WETH).withdraw(amount);\\n        if (to != address(this)) {\\n            _transferEth(to, amount);\\n        }\\n    }\\n\\n    // requires ETH to have been sent to address(this)\\n    function wrapNativeToken(uint256 amount) public payable {\\n        IWETH(WETH).deposit{value: amount}();\\n    }\\n}\",\"keccak256\":\"0x3e9e1156e3842a4467f223b9a1f07499fdc9d3d7f03fd2baf1cb8331753138c7\"},\"contracts/shoyu/lib/LibSushi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\n\\n// returns sorted token addresses, used to handle return values from pairs sorted in this order\\nfunction sortTokens(\\n    address tokenA,\\n    address tokenB\\n) pure returns (address token0, address token1) {\\n    require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n}\\n\\n// calculates the CREATE2 address for a pair without making any external calls\\nfunction pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB,\\n    bytes32 pairCodeHash\\n) pure returns (address pair) {\\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    pair = address(uint160(uint(keccak256(abi.encodePacked(\\n            hex'ff',\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            pairCodeHash // init code hash\\n        )))));\\n}\\n\\n// fetches and sorts the reserves for a pair\\nfunction getReserves(\\n    address factory,\\n    address tokenA,\\n    address tokenB,\\n    bytes32 pairCodeHash\\n) view returns (uint reserveA, uint reserveB) {\\n    (address token0,) = sortTokens(tokenA, tokenB);\\n    (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n}\\n\\n// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\nfunction quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n) pure returns (uint amountB) {\\n    require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n    require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n    amountB = amountA * reserveB / reserveA;\\n}\\n\\n// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\nfunction getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n) pure returns (uint amountOut) {\\n    require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n    require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n    uint amountInWithFee = amountIn* 997;\\n    uint numerator = amountInWithFee * reserveOut;\\n    uint denominator = reserveIn * 1000 + amountInWithFee;\\n    amountOut = numerator / denominator;\\n}\\n\\n// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\nfunction getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n) pure returns (uint amountIn) {\\n    require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n    require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n    uint numerator = reserveIn * amountOut * 1000;\\n    uint denominator = (reserveOut - amountOut) * 997;\\n    amountIn = numerator / denominator + 1;\\n}\\n\\n// performs chained getAmountOut calculations on any number of pairs\\nfunction getAmountsOut(\\n    address factory,\\n    uint amountIn,\\n    address[] memory path,\\n    bytes32 pairCodeHash\\n) view returns (uint[] memory amounts) {\\n    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n    amounts = new uint[](path.length);\\n    amounts[0] = amountIn;\\n    for (uint i; i < path.length - 1; i++) {\\n        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\\n        amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    }\\n}\\n\\n// performs chained getAmountIn calculations on any number of pairs\\nfunction getAmountsIn(\\n    address factory,\\n    uint amountOut,\\n    address[] memory path,\\n    bytes32 pairCodeHash\\n) view returns (uint[] memory amounts) {\\n    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n    amounts = new uint[](path.length);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint i = path.length - 1; i > 0; i--) {\\n        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);\\n        amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    }\\n}\\n\",\"keccak256\":\"0x90269945e5112bf97692b3df244231546062f8b10d787b2db57fae2f5781b0b9\",\"license\":\"MIT\"},\"contracts/shoyu/lib/ShoyuEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nenum TokenSource {\\n    WALLET,\\n    CONDUIT,\\n    BENTO\\n}\",\"keccak256\":\"0x85a8dc0a45565e495b9f0176060a8ba996d84aed03d728ebf2d47c1c1f3a0ca2\",\"license\":\"MIT\"},\"contracts/shoyu/lib/ShoyuStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.7;\\n\\nstruct OrderDetails {\\n    uint256 value;\\n    bytes data;\\n}\\n\\nstruct SwapExactOutDetails {\\n    address[] path;\\n    uint256 amountInMax;\\n    uint256 amountOut;\\n}\\n\\nstruct SwapExactInDetails {\\n    address[] path;\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n}\\n\\nstruct Adapter {\\n    address adapterAddress;\\n    bool isLibrary;\\n    bool isActive;\\n}\",\"keccak256\":\"0xc983dd3701c63c4b2fd8e4fce60df1d631ebb26244d8cfab2868ee6e0f24dda3\",\"license\":\"MIT\"},\"contracts/sushiswap/IBentoBoxMinimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.11;\\n\\n/// @notice Minimal BentoBox vault interface.\\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\\ninterface IBentoBoxMinimal {\\n    /// @notice Balance per ERC-20 token per account in shares.\\n    function balanceOf(address, address) external view returns (uint256);\\n\\n    /// @dev Helper function to represent an `amount` of `token` in shares.\\n    /// @param token The ERC-20 token.\\n    /// @param amount The `token` amount.\\n    /// @param roundUp If the result `share` should be rounded up.\\n    /// @return share The token amount represented in shares.\\n    function toShare(\\n        address token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    /// @dev Helper function to represent shares back into the `token` amount.\\n    /// @param token The ERC-20 token.\\n    /// @param share The amount of shares.\\n    /// @param roundUp If the result should be rounded up.\\n    /// @return amount The share amount back into native representation.\\n    function toAmount(\\n        address token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    /// @notice Registers this contract so that users can approve it for BentoBox.\\n    function registerProtocol() external;\\n\\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\\n    /// @param token_ The ERC-20 token to deposit.\\n    /// @param from which account to pull the tokens.\\n    /// @param to which account to push the tokens.\\n    /// @param amount Token amount in native representation to deposit.\\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\\n    /// @return amountOut The amount deposited.\\n    /// @return shareOut The deposited amount represented in shares.\\n    function deposit(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    /// @notice Withdraws an amount of `token` from a user account.\\n    /// @param token_ The ERC-20 token to withdraw.\\n    /// @param from which user to pull the tokens.\\n    /// @param to which user to push the tokens.\\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\\n    /// @param share Like above, but `share` takes precedence over `amount`.\\n    function withdraw(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n\\n    /// @notice Transfer shares from a user account to another one.\\n    /// @param token The ERC-20 token to transfer.\\n    /// @param from which user to pull the tokens.\\n    /// @param to which user to push the tokens.\\n    /// @param share The amount of `token` in shares.\\n    function transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xc50f00779e912051ed313b14084df6a35bc1bf1b2d14a2e4b0dc0ba52f2efdab\",\"license\":\"GPL-3.0-or-later\"},\"seaport/contracts/conduit/lib/ConduitEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\",\"keccak256\":\"0x1a84850bbff4b820573334c70ee0797462f20fd8c9b86fdebeacc85ecb1963a6\",\"license\":\"MIT\"},\"seaport/contracts/conduit/lib/ConduitStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\",\"keccak256\":\"0xe3e87c74dd79c59293e49b7236cc7befdc19886bb79af5fe53208b1772fd24f9\",\"license\":\"MIT\"},\"seaport/contracts/interfaces/ConduitControllerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(bytes32 conduitKey, address initialOwner)\\n        external\\n        returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(address conduit, address newPotentialOwner)\\n        external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(bytes32 conduitKey)\\n        external\\n        view\\n        returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(address conduit)\\n        external\\n        view\\n        returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(address conduit, address channel)\\n        external\\n        view\\n        returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(address conduit)\\n        external\\n        view\\n        returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(address conduit, uint256 channelIndex)\\n        external\\n        view\\n        returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(address conduit)\\n        external\\n        view\\n        returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\",\"keccak256\":\"0xb124e40645efdf5d92b48fd54eaeb0ba1d05fde62bf51e7684c1bc3bf5343388\",\"license\":\"MIT\"},\"seaport/contracts/interfaces/ConduitInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// prettier-ignore\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\",\"keccak256\":\"0x3f3224e8455ccd73027671e44be8c5a2338c8cd4c0f1dca3fa0f15a44ef14f06\",\"license\":\"MIT\"},\"seaport/contracts/interfaces/TokenTransferrerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has unused parameters. This includes both the token and the\\n     *      identifier parameters for native transfers as well as the identifier\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\n     *      perform this check, leaving it up to the calling channel to enforce\\n     *      when desired.\\n     */\\n    error UnusedItemParameters();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n}\\n\",\"keccak256\":\"0x0a89101400c263654f920aad668249ce67eaebd1af7d5582d38456c8384fc962\",\"license\":\"MIT\"},\"seaport/contracts/lib/TokenTransferrer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title TokenTransferrer\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\n *         by conduits deployed by the ConduitController. Use great caution when\\n *         considering these functions for use in other codebases, as there are\\n *         significant side effects and edge cases that need to be thoroughly\\n *         understood and carefully addressed.\\n */\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            // Scratch space does not need to be cleared ahead of time, as the\\n            // subsequent check will ensure that either at least a full word of\\n            // return data is received (in which case it will be overwritten) or\\n            // that no data is received (in which case scratch space will be\\n            // ignored) on a successful call to the given token.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // Handle cases where either the transfer failed or no data was\\n            // returned. Group these, as most transfers will succeed with data.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed: Equivalent\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\n                // after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory. Round up\\n                                // to the nearest full word.\\n                                let returnDataWords := div(\\n                                    add(returndatasize(), AlmostOneWord),\\n                                    OneWord\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := div(memPointer, OneWord)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            div(\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                ),\\n                                                MemoryExpansionCoefficient\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false or non-compliant return values.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise, revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise, the token just returned no data despite the call\\n                // having succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer. Note that this function does\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\n     *      does not use `safeTransferFrom`).\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The following memory slots will be used when populating call data\\n            // for the transfer; read the values and restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write call data into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer. NOTE: this function is not\\n     *      memory-safe; it will overwrite existing memory, restore the free\\n     *      memory pointer to the default value, and overwrite the zero slot.\\n     *      This function should only be called once memory is no longer\\n     *      required and when uninitialized arrays are not utilized, and memory\\n     *      should be considered fully corrupted (aside from the existence of a\\n     *      default-value free memory pointer) after calling this function.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    mul(idsLength, OneWord)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatchTransfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_calldata_baseSize,\\n                    idsAndAmountsSize\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory. Round up to the nearest full word.\\n                        let returnDataWords := div(\\n                            add(returndatasize(), AlmostOneWord),\\n                            OneWord\\n                        )\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := div(transferDataSize, OneWord)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    div(\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        ),\\n                                        MemoryExpansionCoefficient\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Increase the offset to ids by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\n                    )\\n\\n                    // Increase the offset to amounts by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region. The total size stays the same as\\n                    // `token` uses the same number of bytes as `data.length`.\\n                    revert(0, transferDataSize)\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            // Also note that the zero slot is not reset to zero, meaning empty\\n            // arrays cannot be safely created or utilized until it is restored.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9dd7add814595c3e416dafb8678a33bb037f15fcb0c1f9249472867ec3b5b952\",\"license\":\"MIT\"},\"seaport/contracts/lib/TokenTransferrerConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\n// Note: abbreviated version of above constant to adhere to line length limit.\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\n\",\"keccak256\":\"0xa27ce8b77d5386e95f9b9b4897f1585b78e016c8d1e4c6531fe3b1963cdba08a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61014080604052346200012f5760a08162002d6d803803809162000024828562000134565b8339810103126200012f57806200003f62000077926200016e565b906200004e602082016200016e565b60408201519062000070608062000068606086016200016e565b94016200016e565b9362000183565b604051612b559081620002188239608051818181611281015281816114d101526115d7015260a05181818161125f015281816114af0152611609015260c05181818161066e0152818161070d015281816107f001528181610e2301528181610e9e0152610fcd015260e0518181816118f701528181611c5a0152611ead01526101005181818161191801528181611c7c0152611ecf01526101205181818161042a01528181610ab601528181610b9101526117880152f35b600080fd5b601f909101601f19168101906001600160401b038211908210176200015857604052565b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b03821682036200012f57565b60408051630a96ad3960e01b81529195939492936001600160a01b03939092908416918082600481865afa9081156200020d57600091620001d8575b5060a052506080521660c05260e0526101005261012052565b82813d831162000205575b620001ef818362000134565b81010312620002025750518038620001bf565b80fd5b503d620001e3565b513d6000823e3d90fdfe60806040526004361015610013575b600080fd5b6000803560e01c908162c5a565146100c95750806302232c1f146100c0578063464d91cf146100b757806366c2910d146100ae5780636b2ace87146100a55780638974e2751461009c578063ae40801714610093578063c56420f71461008a5763d75c74621461008257600080fd5b61000e610b4d565b5061000e610a64565b5061000e61096f565b5061000e610814565b5061000e6107a4565b5061000e610588565b5061000e61056d565b5061000e61038e565b60e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101695767ffffffffffffffff6044358181116101655761011490369060040161028a565b6064356101208161026c565b6101286102f2565b60a4359384116101615761014361015c943690600401610301565b9160c4359361015185610384565b60243560043561174c565b604051f35b8480fd5b8280fd5b80fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff81116101b057604052565b6101b861016c565b604052565b60c0810190811067ffffffffffffffff8211176101b057604052565b6080810190811067ffffffffffffffff8211176101b057604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176101b057604052565b60405190610243826101bd565b565b60209067ffffffffffffffff811161025f575b60051b0190565b61026761016c565b610258565b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b81601f8201121561000e578035916102a183610245565b926102af60405194856101f5565b808452602092838086019260051b82010192831161000e578301905b8282106102d9575050505090565b83809183356102e78161026c565b8152019101906102cb565b60843590600382101561000e57565b81601f8201121561000e5780359067ffffffffffffffff8211610377575b6040519261035560207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601856101f5565b8284526020838301011161000e57816000926020809301838601378301015290565b61037f61016c565b61031f565b8015150361000e57565b5060a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5760443567ffffffffffffffff811161000e576103d990369060040161028a565b606435906103e68261026c565b61040a608435916103f683610384565b82156104d95730905b602435600435611e9d565b90610412575b005b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600060405180927f2e1a7d4d00000000000000000000000000000000000000000000000000000000825281838161049089600483019190602083019252565b03925af180156104cc575b6104b3575b5082163014610410575b61041091611852565b806104c06104c69261019c565b80610799565b386104a0565b6104d4610c2e565b61049b565b73ffffffffffffffffffffffffffffffffffffffff8416906103ff565b60a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5760043561052c8161026c565b916024356105398161026c565b9160443591606435600381101561000e57916084359067ffffffffffffffff821161000e5761056a91600401610301565b90565b503461000e5761041061057f366104f6565b93929092610ca2565b503461000e5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5761065260406004356105c981610384565b6024356105d58161026c565b604435916105e28361026c565b6106d1575b82517f02b9446c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201523060248201529116604482015260648035908201526084803590820152918290819060a4820190565b038160a43573ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af180156106c4575b61069d57005b6104109060403d81116106bd575b6106b581836101f5565b810190610c3b565b503d6106ab565b6106cc610c2e565b610697565b82517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301526020908290604490829060009087165af1801561078c575b61075e575b506105e7565b61077e9060203d8111610785575b61077681836101f5565b810190610c19565b5038610758565b503d61076c565b610794610c2e565b610753565b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461000e5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e576004356108508161026c565b60243561085c8161026c565b6044356064359161086b6102f2565b9360a43567ffffffffffffffff811161000e5761088c903690600401610301565b946003811015610962575b806108a95750610410945033906129e4565b806108ba6001929695949396610c81565b036108dd576108d58560208061041098518301019101610c93565b933390611589565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f7472616e736665724552433131353546726f6d2f494e56414c49445f544f4b4560448201527f4e5f534f555243450000000000000000000000000000000000000000000000006064820152608490fd5b61096a610c51565b610897565b503461000e5761097e366104f6565b93906003819493941015610a57575b8061099f5750610410935033906128d6565b806109af60019295949395610c81565b036109d2576109ca8460208061041097518301019101610c93565b923390611475565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f7472616e7366657245524337323146726f6d2f494e56414c49445f544f4b454e60448201527f5f534f55524345000000000000000000000000000000000000000000000000006064820152608490fd5b610a5f610c51565b61098d565b5060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602435600435610a9e8261026c565b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600080916024604051809481937f2e1a7d4d0000000000000000000000000000000000000000000000000000000083528860048401525af18015610b40575b610b2d575b5030908316036104aa57005b806104c0610b3a9261019c565b38610b21565b610b48610c2e565b610b1c565b50600060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101695773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001681813b1561016957600491604051928380927fd0e30db00000000000000000000000000000000000000000000000000000000082528235905af18015610c0c575b610bfd575b50604051f35b610c069061019c565b38610bf7565b610c14610c2e565b610bf2565b9081602091031261000e575161056a81610384565b506040513d6000823e3d90fd5b919082604091031261000e576020825192015190565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60031115610c8b57565b610243610c51565b9081602091031261000e575190565b909192610cae81610c81565b80610cc0575061024393503390612766565b610ccd8194939294610c81565b60018103610cf45750610cec8460208061024397518301019101610c93565b923390611225565b80610d00600292610c81565b03610d2357610d1b8460208061024397518301019101610c19565b923390610da8565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f7472616e73666572455243323046726f6d2f494e56414c49445f544f4b454e5f60448201527f534f5552434500000000000000000000000000000000000000000000000000006064820152608490fd5b909192600094600014610e7c57604080517f97da6d3000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152938316602485015293821660448401526064830152608482019390935291829060a49082906000907f0000000000000000000000000000000000000000000000000000000000000000165af18015610e6f575b610e54575b50565b610e6b9060403d81116106bd576106b581836101f5565b5050565b610e77610c2e565b610e4c565b8093929193610f58575b5073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b1561000e576040517ff18d03cc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9485166004820152908416602482015291909216604482015260648101929092526000908290608490829084905af18015610f4b575b610f3e5750565b806104c06102439261019c565b610f53610c2e565b610f37565b6040517fda5139ca00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024810191909152600060448201529093906020818060648101038173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa918215611033575b91611005575b509238610e86565b611026915060203d811161102c575b61101e81836101f5565b810190610c93565b38610ffd565b503d611014565b61103b610c2e565b610ff7565b60409081519180830183811067ffffffffffffffff8211176110b9575b815260018352829160005b6020808210156110b157835160209291611081826101bd565b600082526000818301526000868301526000606083015260006080830152600060a0830152828801015201611068565b505091925050565b6110c161016c565b61105d565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602090805115611104570190565b61110c6110c6565b0190565b604090805160011015611104570190565b6020918151811015611136575b60051b010190565b61113e6110c6565b61112e565b9081602091031261000e57517fffffffff000000000000000000000000000000000000000000000000000000008116810361000e5790565b60208082019080835283518092528060408094019401926000905b8382106111a557505050505090565b90919293948360c0600192885180516004811015611218575b825273ffffffffffffffffffffffffffffffffffffffff80858301511685840152808783015116878401526060908183015116908301526080808201519083015260a0809101519082015201960192019093929193611196565b611220610c51565b6111be565b9061142e92916020946113d761136361134a6040518981019061132e8161130273ffffffffffffffffffffffffffffffffffffffff9e8f907f0000000000000000000000000000000000000000000000000000000000000000917f00000000000000000000000000000000000000000000000000000000000000001687917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000605594927fff00000000000000000000000000000000000000000000000000000000000000855260601b166001840152601583015260358201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826101f5565b51902073ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b946113ba61136f611040565b9561139d61137b610236565b60018152965b73ffffffffffffffffffffffffffffffffffffffff16878c0152565b73ffffffffffffffffffffffffffffffffffffffff166040860152565b73ffffffffffffffffffffffffffffffffffffffff166060840152565b6000608083015260a08201526113ec826110f6565b526113f6816110f6565b5060006040519586809581947f4ce34aa20000000000000000000000000000000000000000000000000000000083526004830161117b565b0393165af18015611468575b6114415750565b610e519060203d8111611461575b61145981836101f5565b810190611143565b503d61144f565b611470610c2e565b61143a565b9061142e929160209461157461155261134a6040518981019061132e8161130273ffffffffffffffffffffffffffffffffffffffff9e8f907f0000000000000000000000000000000000000000000000000000000000000000917f00000000000000000000000000000000000000000000000000000000000000001687917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000605594927fff00000000000000000000000000000000000000000000000000000000000000855260601b166001840152601583015260358201520190565b946113ba61155e611040565b9561139d61156a610236565b6002815296611381565b6080820152600160a08201526113ec826110f6565b6040517fff00000000000000000000000000000000000000000000000000000000000000602082019081527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b16602183015260358201979097527f0000000000000000000000000000000000000000000000000000000000000000605580830191909152815273ffffffffffffffffffffffffffffffffffffffff969395929491939061165b6075826101f5565b51902073ffffffffffffffffffffffffffffffffffffffff169461167d611040565b94611686610236565b600381529473ffffffffffffffffffffffffffffffffffffffff16602086015273ffffffffffffffffffffffffffffffffffffffff16604085015273ffffffffffffffffffffffffffffffffffffffff166060840152608083015260a08201526116ef826110f6565b526116f9816110f6565b50604051928380927f4ce34aa200000000000000000000000000000000000000000000000000000000825260048201906117329161117b565b03921691815a602094600091f18015611468576114415750565b94919061176793969491856000146118355730915b876118ef565b50611770575050565b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600060405180927f2e1a7d4d0000000000000000000000000000000000000000000000000000000082528183816117ee89600483019190602083019252565b03925af18015611828575b611815575b50309083160361180c575050565b61024391611852565b806104c06118229261019c565b386117fe565b611830610c2e565b6117f9565b73ffffffffffffffffffffffffffffffffffffffff881691611761565b60008080809481945af1156101695750565b1561186b57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f5f6c65676163795377617045786163744f75742f4558434553534956455f414d60448201527f4f554e545f494e000000000000000000000000000000000000000000000000006064820152fd5b9295949193907f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006119456002885110156121e5565b61194f875161224a565b9586519060018210611a69575b61196b60001980930189611121565b52875160018110611a5c575b01805b6119f85750926119f3926102439795926119ed889661199c6119a89d9a6110f6565b519c8d94851115611864565b6119ce6119b48a6110f6565b5173ffffffffffffffffffffffffffffffffffffffff1690565b926119db6119b48b6110f6565b6119e76119b48c611110565b91612103565b90610ca2565b611c53565b80611a3e611a2d848b611a266119b486611a206119b4611a1a611a569b611abe565b86611121565b93611121565b9088612366565b90611a38848c611121565b51612673565b611a50611a4a83611abe565b8a611121565b52612665565b8061197a565b611a64611a76565b611977565b611a71611a76565b61195c565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001906000198114611ab6570190565b61110c611a76565b6000199060018110611ab6570190565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9060028110611ab6570190565b818110611b07570390565b611b0f611a76565b0390565b6001907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8111611ab6570190565b6002907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8111611ab6570190565b81198111611ab6570190565b604051906000602083019280841067ffffffffffffffff851117611ba7575b8360405281815292369037565b611baf61016c565b611b9a565b9273ffffffffffffffffffffffffffffffffffffffff91959495845260209283850152166040830152608060608301528351908160808401526000945b828610611c3d575050601f817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09260a0959611611c30575b0116010190565b6000858286010152611c29565b85810182015184870160a0015294810194611bf1565b92919260007f0000000000000000000000000000000000000000000000000000000000000000927f0000000000000000000000000000000000000000000000000000000000000000915b611ca78251611abe565b811015611e095780611cbd6119b4899385611121565b611ccc6119b4611a1a84611b13565b85611cd78284611fe5565b5091868a611ced611ce788611b13565b8c611121565b519473ffffffffffffffffffffffffffffffffffffffff878116911603611def57928261134a9282611d569661134a968b60009a9d5b611d2d8651611ace565b821015611de357506119b4611d4e95611d486119e793611b41565b90611121565b965b8d612103565b91611d5f611b7b565b92803b1561000e57611dbe9560008094611da8604051978896879586947f022c0d9f00000000000000000000000000000000000000000000000000000000865260048601611bb4565b03925af18015611dd6575b611dc3575b50611aa6565b611c9d565b806104c0611dd09261019c565b38611db8565b611dde610c2e565b611db3565b94505050505096611d50565b939261134a9261134a9282611d569697838b60009d611d23565b50505050509050565b15611e1957565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f5f6c6567616379537761704578616374496e2f4558434553534956455f414d4f60448201527f554e545f4f5554000000000000000000000000000000000000000000000000006064820152fd5b916102439294939194611fa460207f0000000000000000000000000000000000000000000000000000000000000000927f000000000000000000000000000000000000000000000000000000000000000093611f4a611efe86888585612299565b95611f1f611f15611f0f8951611abe565b89611121565b519c8d1015611e12565b611f3161134a61134a6119b48b6110f6565b92611f3e6119b48a6110f6565b6119e76119b48b611110565b60006040518096819582947fa9059cbb000000000000000000000000000000000000000000000000000000008452600484016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b03925af18015611fd8575b611fba575b50611c53565b611fd19060203d81116107855761077681836101f5565b5038611fb4565b611fe0610c2e565b611faf565b909173ffffffffffffffffffffffffffffffffffffffff9182841683821681811461207f57101561207a57925b9183161561201c57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056324c6962726172793a205a45524f5f4144445245535300006044820152fd5b612012565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f556e697377617056324c6962726172793a204944454e544943414c5f4144445260448201527f45535345530000000000000000000000000000000000000000000000000000006064820152fd5b919261212673ffffffffffffffffffffffffffffffffffffffff9460b593611fe5565b6040939193519060208201947fffffffffffffffffffffffffffffffffffffffff0000000000000000000000009182809260601b16875260601b16603483015260288252606082019482861067ffffffffffffffff8711176121d8575b85604052825190209060808301967fff00000000000000000000000000000000000000000000000000000000000000885260601b16608183015260958201520152605581526121d1816101d9565b5190201690565b6121e061016c565b612183565b156121ec57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056324c6962726172793a20494e56414c49445f5041544800006044820152fd5b9061225482610245565b61226160405191826101f5565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061228f8294610245565b0190602036910137565b909392916122ab6002825110156121e5565b6122b5815161224a565b9485511561233e575b602086015260005b600019825160018110612331575b0181101561232b5780612314612303866122f46119b46123269688611121565b611a266119b4611f0f87611b13565b9061230e848b611121565b51612579565b612320611f0f83611b13565b52611aa6565b6122c6565b50505050565b612339611a76565b6122d4565b6123466110c6565b6122be565b51906dffffffffffffffffffffffffffff8216820361000e57565b6060829161239a6004959661237b8886611fe5565b509773ffffffffffffffffffffffffffffffffffffffff958694612103565b16604051948580927f0902f1ac0000000000000000000000000000000000000000000000000000000082525afa92831561245b575b6000908194612403575b5081906dffffffffffffffffffffffffffff809116941694169116146000146123ff5791565b9091565b93506060843d8211612453575b8161241d606093836101f5565b810103126101695761242e8461234b565b90604061243d6020870161234b565b95015163ffffffff8116036101695750816123d9565b3d9150612410565b612463610c2e565b6123cf565b1561246f57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152fd5b6103e890806000190482118115151661250a570290565b612512611a76565b0290565b6103e590806000190482118115151661250a570290565b806000190482118115151661250a570290565b811561254a570490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b80156125e15761056a926125c06125ba6125c593851515806125d8575b61259f90612468565b6103e590806000190482116001166125cb575b02928361252d565b936124f3565b611b6f565b90612540565b6125d3611a76565b6125b2565b50831515612596565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4960448201527f4e5055545f414d4f554e540000000000000000000000000000000000000000006064820152fd5b600019908015611ab6570190565b80156126e25761056a926126c06126bb6126a284866126c7971515806126d9575b61269d90612468565b61252d565b936103e89385600019048511861515166126cc57611afc565b612516565b9102612540565b611b13565b6126d4611a76565b611afc565b50851515612694565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4f60448201527f55545055545f414d4f554e5400000000000000000000000000000000000000006064820152fd5b9092604051926000947f23b872dd00000000000000000000000000000000000000000000000000000000865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d15158116156127d0575b505050505050604052606052565b80863b1515166127c25790879596911561281057602486887f5f15d672000000000000000000000000000000000000000000000000000000008252600452fd5b1561284a57506084947f98891923000000000000000000000000000000000000000000000000000000008552600452602452604452606452fd5b3d612889575b5060a4947ff486bc8700000000000000000000000000000000000000000000000000000000855260045260245260445281606452608452fd5b601f3d0160051c9060051c9080600302918082116128bd575b505060205a9101106128b45785612850565b833d81803e3d90fd5b8080600392028380020360091c920302010186806128a2565b9092813b156129b657604051926000947f23b872dd000000000000000000000000000000000000000000000000000000008652806004528160245282604452858060648180885af11561292f5750505050604052606052565b8593943d612972575b5060a4947ff486bc870000000000000000000000000000000000000000000000000000000085526004526024526044526064526001608452fd5b601f3d0160051c9060051c90806003029180821161299d575b505060205a9101106128b45785612938565b8080600392028380020360091c9203020101868061298b565b507f5f15d6720000000000000000000000000000000000000000000000000000000060005260045260246000fd5b929093833b15612af157604051936080519160a0519360c051956000987ff242432a000000000000000000000000000000000000000000000000000000008a528060045281602452826044528360645260a06084528960a452898060c48180895af115612a6157505050505060805260a05260c052604052606052565b89949550883d612aa4575b5060a4957ff486bc87000000000000000000000000000000000000000000000000000000008652600452602452604452606452608452fd5b601f3d0160051c9060051c908060030291808211612ad8575b505060205a910110612acf5786612a6c565b843d81803e3d90fd5b8080600392028380020360091c92030201018780612abd565b837f5f15d6720000000000000000000000000000000000000000000000000000000060005260045260246000fdfea264697066735822122050034e8018bb6ec6bb52e1d096bfd43751607ee40de1997adff12d9f6494880d64736f6c634300080e0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b6000803560e01c908162c5a565146100c95750806302232c1f146100c0578063464d91cf146100b757806366c2910d146100ae5780636b2ace87146100a55780638974e2751461009c578063ae40801714610093578063c56420f71461008a5763d75c74621461008257600080fd5b61000e610b4d565b5061000e610a64565b5061000e61096f565b5061000e610814565b5061000e6107a4565b5061000e610588565b5061000e61056d565b5061000e61038e565b60e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101695767ffffffffffffffff6044358181116101655761011490369060040161028a565b6064356101208161026c565b6101286102f2565b60a4359384116101615761014361015c943690600401610301565b9160c4359361015185610384565b60243560043561174c565b604051f35b8480fd5b8280fd5b80fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff81116101b057604052565b6101b861016c565b604052565b60c0810190811067ffffffffffffffff8211176101b057604052565b6080810190811067ffffffffffffffff8211176101b057604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176101b057604052565b60405190610243826101bd565b565b60209067ffffffffffffffff811161025f575b60051b0190565b61026761016c565b610258565b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b81601f8201121561000e578035916102a183610245565b926102af60405194856101f5565b808452602092838086019260051b82010192831161000e578301905b8282106102d9575050505090565b83809183356102e78161026c565b8152019101906102cb565b60843590600382101561000e57565b81601f8201121561000e5780359067ffffffffffffffff8211610377575b6040519261035560207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601856101f5565b8284526020838301011161000e57816000926020809301838601378301015290565b61037f61016c565b61031f565b8015150361000e57565b5060a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5760443567ffffffffffffffff811161000e576103d990369060040161028a565b606435906103e68261026c565b61040a608435916103f683610384565b82156104d95730905b602435600435611e9d565b90610412575b005b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600060405180927f2e1a7d4d00000000000000000000000000000000000000000000000000000000825281838161049089600483019190602083019252565b03925af180156104cc575b6104b3575b5082163014610410575b61041091611852565b806104c06104c69261019c565b80610799565b386104a0565b6104d4610c2e565b61049b565b73ffffffffffffffffffffffffffffffffffffffff8416906103ff565b60a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5760043561052c8161026c565b916024356105398161026c565b9160443591606435600381101561000e57916084359067ffffffffffffffff821161000e5761056a91600401610301565b90565b503461000e5761041061057f366104f6565b93929092610ca2565b503461000e5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5761065260406004356105c981610384565b6024356105d58161026c565b604435916105e28361026c565b6106d1575b82517f02b9446c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201523060248201529116604482015260648035908201526084803590820152918290819060a4820190565b038160a43573ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af180156106c4575b61069d57005b6104109060403d81116106bd575b6106b581836101f5565b810190610c3b565b503d6106ab565b6106cc610c2e565b610697565b82517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301526020908290604490829060009087165af1801561078c575b61075e575b506105e7565b61077e9060203d8111610785575b61077681836101f5565b810190610c19565b5038610758565b503d61076c565b610794610c2e565b610753565b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461000e5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e576004356108508161026c565b60243561085c8161026c565b6044356064359161086b6102f2565b9360a43567ffffffffffffffff811161000e5761088c903690600401610301565b946003811015610962575b806108a95750610410945033906129e4565b806108ba6001929695949396610c81565b036108dd576108d58560208061041098518301019101610c93565b933390611589565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f7472616e736665724552433131353546726f6d2f494e56414c49445f544f4b4560448201527f4e5f534f555243450000000000000000000000000000000000000000000000006064820152608490fd5b61096a610c51565b610897565b503461000e5761097e366104f6565b93906003819493941015610a57575b8061099f5750610410935033906128d6565b806109af60019295949395610c81565b036109d2576109ca8460208061041097518301019101610c93565b923390611475565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f7472616e7366657245524337323146726f6d2f494e56414c49445f544f4b454e60448201527f5f534f55524345000000000000000000000000000000000000000000000000006064820152608490fd5b610a5f610c51565b61098d565b5060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602435600435610a9e8261026c565b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600080916024604051809481937f2e1a7d4d0000000000000000000000000000000000000000000000000000000083528860048401525af18015610b40575b610b2d575b5030908316036104aa57005b806104c0610b3a9261019c565b38610b21565b610b48610c2e565b610b1c565b50600060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101695773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001681813b1561016957600491604051928380927fd0e30db00000000000000000000000000000000000000000000000000000000082528235905af18015610c0c575b610bfd575b50604051f35b610c069061019c565b38610bf7565b610c14610c2e565b610bf2565b9081602091031261000e575161056a81610384565b506040513d6000823e3d90fd5b919082604091031261000e576020825192015190565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60031115610c8b57565b610243610c51565b9081602091031261000e575190565b909192610cae81610c81565b80610cc0575061024393503390612766565b610ccd8194939294610c81565b60018103610cf45750610cec8460208061024397518301019101610c93565b923390611225565b80610d00600292610c81565b03610d2357610d1b8460208061024397518301019101610c19565b923390610da8565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f7472616e73666572455243323046726f6d2f494e56414c49445f544f4b454e5f60448201527f534f5552434500000000000000000000000000000000000000000000000000006064820152608490fd5b909192600094600014610e7c57604080517f97da6d3000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152938316602485015293821660448401526064830152608482019390935291829060a49082906000907f0000000000000000000000000000000000000000000000000000000000000000165af18015610e6f575b610e54575b50565b610e6b9060403d81116106bd576106b581836101f5565b5050565b610e77610c2e565b610e4c565b8093929193610f58575b5073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b1561000e576040517ff18d03cc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9485166004820152908416602482015291909216604482015260648101929092526000908290608490829084905af18015610f4b575b610f3e5750565b806104c06102439261019c565b610f53610c2e565b610f37565b6040517fda5139ca00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024810191909152600060448201529093906020818060648101038173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa918215611033575b91611005575b509238610e86565b611026915060203d811161102c575b61101e81836101f5565b810190610c93565b38610ffd565b503d611014565b61103b610c2e565b610ff7565b60409081519180830183811067ffffffffffffffff8211176110b9575b815260018352829160005b6020808210156110b157835160209291611081826101bd565b600082526000818301526000868301526000606083015260006080830152600060a0830152828801015201611068565b505091925050565b6110c161016c565b61105d565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602090805115611104570190565b61110c6110c6565b0190565b604090805160011015611104570190565b6020918151811015611136575b60051b010190565b61113e6110c6565b61112e565b9081602091031261000e57517fffffffff000000000000000000000000000000000000000000000000000000008116810361000e5790565b60208082019080835283518092528060408094019401926000905b8382106111a557505050505090565b90919293948360c0600192885180516004811015611218575b825273ffffffffffffffffffffffffffffffffffffffff80858301511685840152808783015116878401526060908183015116908301526080808201519083015260a0809101519082015201960192019093929193611196565b611220610c51565b6111be565b9061142e92916020946113d761136361134a6040518981019061132e8161130273ffffffffffffffffffffffffffffffffffffffff9e8f907f0000000000000000000000000000000000000000000000000000000000000000917f00000000000000000000000000000000000000000000000000000000000000001687917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000605594927fff00000000000000000000000000000000000000000000000000000000000000855260601b166001840152601583015260358201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826101f5565b51902073ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b946113ba61136f611040565b9561139d61137b610236565b60018152965b73ffffffffffffffffffffffffffffffffffffffff16878c0152565b73ffffffffffffffffffffffffffffffffffffffff166040860152565b73ffffffffffffffffffffffffffffffffffffffff166060840152565b6000608083015260a08201526113ec826110f6565b526113f6816110f6565b5060006040519586809581947f4ce34aa20000000000000000000000000000000000000000000000000000000083526004830161117b565b0393165af18015611468575b6114415750565b610e519060203d8111611461575b61145981836101f5565b810190611143565b503d61144f565b611470610c2e565b61143a565b9061142e929160209461157461155261134a6040518981019061132e8161130273ffffffffffffffffffffffffffffffffffffffff9e8f907f0000000000000000000000000000000000000000000000000000000000000000917f00000000000000000000000000000000000000000000000000000000000000001687917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000605594927fff00000000000000000000000000000000000000000000000000000000000000855260601b166001840152601583015260358201520190565b946113ba61155e611040565b9561139d61156a610236565b6002815296611381565b6080820152600160a08201526113ec826110f6565b6040517fff00000000000000000000000000000000000000000000000000000000000000602082019081527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b16602183015260358201979097527f0000000000000000000000000000000000000000000000000000000000000000605580830191909152815273ffffffffffffffffffffffffffffffffffffffff969395929491939061165b6075826101f5565b51902073ffffffffffffffffffffffffffffffffffffffff169461167d611040565b94611686610236565b600381529473ffffffffffffffffffffffffffffffffffffffff16602086015273ffffffffffffffffffffffffffffffffffffffff16604085015273ffffffffffffffffffffffffffffffffffffffff166060840152608083015260a08201526116ef826110f6565b526116f9816110f6565b50604051928380927f4ce34aa200000000000000000000000000000000000000000000000000000000825260048201906117329161117b565b03921691815a602094600091f18015611468576114415750565b94919061176793969491856000146118355730915b876118ef565b50611770575050565b73ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016803b1561000e57600060405180927f2e1a7d4d0000000000000000000000000000000000000000000000000000000082528183816117ee89600483019190602083019252565b03925af18015611828575b611815575b50309083160361180c575050565b61024391611852565b806104c06118229261019c565b386117fe565b611830610c2e565b6117f9565b73ffffffffffffffffffffffffffffffffffffffff881691611761565b60008080809481945af1156101695750565b1561186b57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f5f6c65676163795377617045786163744f75742f4558434553534956455f414d60448201527f4f554e545f494e000000000000000000000000000000000000000000000000006064820152fd5b9295949193907f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006119456002885110156121e5565b61194f875161224a565b9586519060018210611a69575b61196b60001980930189611121565b52875160018110611a5c575b01805b6119f85750926119f3926102439795926119ed889661199c6119a89d9a6110f6565b519c8d94851115611864565b6119ce6119b48a6110f6565b5173ffffffffffffffffffffffffffffffffffffffff1690565b926119db6119b48b6110f6565b6119e76119b48c611110565b91612103565b90610ca2565b611c53565b80611a3e611a2d848b611a266119b486611a206119b4611a1a611a569b611abe565b86611121565b93611121565b9088612366565b90611a38848c611121565b51612673565b611a50611a4a83611abe565b8a611121565b52612665565b8061197a565b611a64611a76565b611977565b611a71611a76565b61195c565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001906000198114611ab6570190565b61110c611a76565b6000199060018110611ab6570190565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9060028110611ab6570190565b818110611b07570390565b611b0f611a76565b0390565b6001907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8111611ab6570190565b6002907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8111611ab6570190565b81198111611ab6570190565b604051906000602083019280841067ffffffffffffffff851117611ba7575b8360405281815292369037565b611baf61016c565b611b9a565b9273ffffffffffffffffffffffffffffffffffffffff91959495845260209283850152166040830152608060608301528351908160808401526000945b828610611c3d575050601f817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09260a0959611611c30575b0116010190565b6000858286010152611c29565b85810182015184870160a0015294810194611bf1565b92919260007f0000000000000000000000000000000000000000000000000000000000000000927f0000000000000000000000000000000000000000000000000000000000000000915b611ca78251611abe565b811015611e095780611cbd6119b4899385611121565b611ccc6119b4611a1a84611b13565b85611cd78284611fe5565b5091868a611ced611ce788611b13565b8c611121565b519473ffffffffffffffffffffffffffffffffffffffff878116911603611def57928261134a9282611d569661134a968b60009a9d5b611d2d8651611ace565b821015611de357506119b4611d4e95611d486119e793611b41565b90611121565b965b8d612103565b91611d5f611b7b565b92803b1561000e57611dbe9560008094611da8604051978896879586947f022c0d9f00000000000000000000000000000000000000000000000000000000865260048601611bb4565b03925af18015611dd6575b611dc3575b50611aa6565b611c9d565b806104c0611dd09261019c565b38611db8565b611dde610c2e565b611db3565b94505050505096611d50565b939261134a9261134a9282611d569697838b60009d611d23565b50505050509050565b15611e1957565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f5f6c6567616379537761704578616374496e2f4558434553534956455f414d4f60448201527f554e545f4f5554000000000000000000000000000000000000000000000000006064820152fd5b916102439294939194611fa460207f0000000000000000000000000000000000000000000000000000000000000000927f000000000000000000000000000000000000000000000000000000000000000093611f4a611efe86888585612299565b95611f1f611f15611f0f8951611abe565b89611121565b519c8d1015611e12565b611f3161134a61134a6119b48b6110f6565b92611f3e6119b48a6110f6565b6119e76119b48b611110565b60006040518096819582947fa9059cbb000000000000000000000000000000000000000000000000000000008452600484016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b03925af18015611fd8575b611fba575b50611c53565b611fd19060203d81116107855761077681836101f5565b5038611fb4565b611fe0610c2e565b611faf565b909173ffffffffffffffffffffffffffffffffffffffff9182841683821681811461207f57101561207a57925b9183161561201c57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056324c6962726172793a205a45524f5f4144445245535300006044820152fd5b612012565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f556e697377617056324c6962726172793a204944454e544943414c5f4144445260448201527f45535345530000000000000000000000000000000000000000000000000000006064820152fd5b919261212673ffffffffffffffffffffffffffffffffffffffff9460b593611fe5565b6040939193519060208201947fffffffffffffffffffffffffffffffffffffffff0000000000000000000000009182809260601b16875260601b16603483015260288252606082019482861067ffffffffffffffff8711176121d8575b85604052825190209060808301967fff00000000000000000000000000000000000000000000000000000000000000885260601b16608183015260958201520152605581526121d1816101d9565b5190201690565b6121e061016c565b612183565b156121ec57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056324c6962726172793a20494e56414c49445f5041544800006044820152fd5b9061225482610245565b61226160405191826101f5565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061228f8294610245565b0190602036910137565b909392916122ab6002825110156121e5565b6122b5815161224a565b9485511561233e575b602086015260005b600019825160018110612331575b0181101561232b5780612314612303866122f46119b46123269688611121565b611a266119b4611f0f87611b13565b9061230e848b611121565b51612579565b612320611f0f83611b13565b52611aa6565b6122c6565b50505050565b612339611a76565b6122d4565b6123466110c6565b6122be565b51906dffffffffffffffffffffffffffff8216820361000e57565b6060829161239a6004959661237b8886611fe5565b509773ffffffffffffffffffffffffffffffffffffffff958694612103565b16604051948580927f0902f1ac0000000000000000000000000000000000000000000000000000000082525afa92831561245b575b6000908194612403575b5081906dffffffffffffffffffffffffffff809116941694169116146000146123ff5791565b9091565b93506060843d8211612453575b8161241d606093836101f5565b810103126101695761242e8461234b565b90604061243d6020870161234b565b95015163ffffffff8116036101695750816123d9565b3d9150612410565b612463610c2e565b6123cf565b1561246f57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4c60448201527f49515549444954590000000000000000000000000000000000000000000000006064820152fd5b6103e890806000190482118115151661250a570290565b612512611a76565b0290565b6103e590806000190482118115151661250a570290565b806000190482118115151661250a570290565b811561254a570490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b80156125e15761056a926125c06125ba6125c593851515806125d8575b61259f90612468565b6103e590806000190482116001166125cb575b02928361252d565b936124f3565b611b6f565b90612540565b6125d3611a76565b6125b2565b50831515612596565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4960448201527f4e5055545f414d4f554e540000000000000000000000000000000000000000006064820152fd5b600019908015611ab6570190565b80156126e25761056a926126c06126bb6126a284866126c7971515806126d9575b61269d90612468565b61252d565b936103e89385600019048511861515166126cc57611afc565b612516565b9102612540565b611b13565b6126d4611a76565b611afc565b50851515612694565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f556e697377617056324c6962726172793a20494e53554646494349454e545f4f60448201527f55545055545f414d4f554e5400000000000000000000000000000000000000006064820152fd5b9092604051926000947f23b872dd00000000000000000000000000000000000000000000000000000000865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d15158116156127d0575b505050505050604052606052565b80863b1515166127c25790879596911561281057602486887f5f15d672000000000000000000000000000000000000000000000000000000008252600452fd5b1561284a57506084947f98891923000000000000000000000000000000000000000000000000000000008552600452602452604452606452fd5b3d612889575b5060a4947ff486bc8700000000000000000000000000000000000000000000000000000000855260045260245260445281606452608452fd5b601f3d0160051c9060051c9080600302918082116128bd575b505060205a9101106128b45785612850565b833d81803e3d90fd5b8080600392028380020360091c920302010186806128a2565b9092813b156129b657604051926000947f23b872dd000000000000000000000000000000000000000000000000000000008652806004528160245282604452858060648180885af11561292f5750505050604052606052565b8593943d612972575b5060a4947ff486bc870000000000000000000000000000000000000000000000000000000085526004526024526044526064526001608452fd5b601f3d0160051c9060051c90806003029180821161299d575b505060205a9101106128b45785612938565b8080600392028380020360091c9203020101868061298b565b507f5f15d6720000000000000000000000000000000000000000000000000000000060005260045260246000fd5b929093833b15612af157604051936080519160a0519360c051956000987ff242432a000000000000000000000000000000000000000000000000000000008a528060045281602452826044528360645260a06084528960a452898060c48180895af115612a6157505050505060805260a05260c052604052606052565b89949550883d612aa4575b5060a4957ff486bc87000000000000000000000000000000000000000000000000000000008652600452602452604452606452608452fd5b601f3d0160051c9060051c908060030291808211612ad8575b505060205a910110612acf5786612a6c565b843d81803e3d90fd5b8080600392028380020360091c92030201018780612abd565b837f5f15d6720000000000000000000000000000000000000000000000000000000060005260045260246000fdfea264697066735822122050034e8018bb6ec6bb52e1d096bfd43751607ee40de1997adff12d9f6494880d64736f6c634300080e0033",
  "devdoc": {
    "errors": {
      "BadReturnValueFromERC20OnTransfer(address,address,address,uint256)": [
        {
          "details": "Revert with an error when an ERC20 token transfer returns a falsey      value.",
          "params": {
            "amount": "The amount for the attempted ERC20 transfer.",
            "from": "The source of the attempted ERC20 transfer.",
            "to": "The recipient of the attempted ERC20 transfer.",
            "token": "The token for which the ERC20 transfer was attempted."
          }
        }
      ],
      "ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])": [
        {
          "details": "Revert with an error when a batch ERC1155 token transfer reverts.",
          "params": {
            "amounts": "The amounts for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifiers": "The identifiers for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "Invalid1155BatchTransferEncoding()": [
        {
          "details": "Revert with an error when attempting to execute an 1155 batch      transfer using calldata not produced by default ABI encoding or with      different lengths for ids and amounts arrays."
        }
      ],
      "InvalidERC721TransferAmount()": [
        {
          "details": "Revert with an error when an ERC721 transfer with amount other than      one is attempted."
        }
      ],
      "MissingItemAmount()": [
        {
          "details": "Revert with an error when attempting to fulfill an order where an      item has an amount of zero."
        }
      ],
      "NoContract(address)": [
        {
          "details": "Revert with an error when an account being called as an assumed      contract does not have code and returns no data.",
          "params": {
            "account": "The account that should contain code."
          }
        }
      ],
      "TokenTransferGenericFailure(address,address,address,uint256,uint256)": [
        {
          "details": "Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.",
          "params": {
            "amount": "The amount for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifier": "The identifier for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "UnusedItemParameters()": [
        {
          "details": "Revert with an error when attempting to fulfill an order where an      item has unused parameters. This includes both the token and the      identifier parameters for native transfers as well as the identifier      parameter for ERC20 transfers. Note that the conduit does not      perform this check, leaving it up to the calling channel to enforce      when desired."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}